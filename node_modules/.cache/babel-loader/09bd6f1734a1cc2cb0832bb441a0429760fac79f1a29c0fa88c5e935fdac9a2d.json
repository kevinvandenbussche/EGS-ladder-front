{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  createNodeMap\n} = require('./nodeMap');\nconst {\n  isKeyword\n} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst jsonCanonicalize = require('canonicalize');\nconst types = require('./types');\nconst util = require('./util');\nconst {\n  handleEvent: _handleEvent\n} = require('./events');\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING\n} = require('./constants');\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {\n    '@default': {}\n  };\n  createNodeMap(input, nodeMap, '@default', issuer);\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for (const graphName of graphNames) {\n    let graphTerm;\n    if (graphName === '@default') {\n      graphTerm = {\n        termType: 'DefaultGraph',\n        value: ''\n      };\n    } else if (_isAbsoluteIri(graphName)) {\n      if (graphName.startsWith('_:')) {\n        graphTerm = {\n          termType: 'BlankNode'\n        };\n      } else {\n        graphTerm = {\n          termType: 'NamedNode'\n        };\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      if (options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'relative graph reference',\n            level: 'warning',\n            message: 'Relative graph reference found.',\n            details: {\n              graph: graphName\n            }\n          },\n          options\n        });\n      }\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for (const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for (let property of properties) {\n      const items = node[property];\n      if (property === '@type') {\n        property = RDF_TYPE;\n      } else if (isKeyword(property)) {\n        continue;\n      }\n      for (const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if (!_isAbsoluteIri(id)) {\n          if (options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative subject reference',\n                level: 'warning',\n                message: 'Relative subject reference found.',\n                details: {\n                  subject: id\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if (!_isAbsoluteIri(property)) {\n          if (options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative predicate reference',\n                level: 'warning',\n                message: 'Relative predicate reference found.',\n                details: {\n                  predicate: property\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if (predicate.termType === 'BlankNode' && !options.produceGeneralizedRdf) {\n          if (options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'blank node predicate',\n                level: 'warning',\n                message: 'Dropping blank node predicate.',\n                details: {\n                  // FIXME: add better issuer API to get reverse mapping\n                  property: issuer.getOldIds().find(key => issuer.getId(key) === property)\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection, options);\n        // skip null objects (they are relative IRIs)\n        if (object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n * @param options the RDF serialization options.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection, options) {\n  const first = {\n    termType: 'NamedNode',\n    value: RDF_FIRST\n  };\n  const rest = {\n    termType: 'NamedNode',\n    value: RDF_REST\n  };\n  const nil = {\n    termType: 'NamedNode',\n    value: RDF_NIL\n  };\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {\n    termType: 'BlankNode',\n    value: issuer.getId()\n  } : nil;\n  let subject = result;\n  for (const item of list) {\n    const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection, options);\n    const next = {\n      termType: 'BlankNode',\n      value: issuer.getId()\n    };\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if (last) {\n    const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection, options);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n * @param options the RDF serialization options.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection, options) {\n  const object = {};\n\n  // convert value object to RDF\n  if (graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if (datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if (types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if (!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if (types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if (rdfDirection === 'i18n-datatype' && '@direction' in item) {\n      const datatype = 'https://www.w3.org/ns/i18n#' + (item['@language'] || '') + `_${item['@direction']}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if ('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if (graphTypes.isList(item)) {\n    const _list = _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection, options);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if (object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    if (options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'relative object reference',\n          level: 'warning',\n          message: 'Relative object reference found.',\n          details: {\n            object: object.value\n          }\n        },\n        options\n      });\n    }\n    return null;\n  }\n  return object;\n}","map":{"version":3,"names":["createNodeMap","require","isKeyword","graphTypes","jsonCanonicalize","types","util","handleEvent","_handleEvent","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","RDF_LANGSTRING","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","isAbsolute","_isAbsoluteIri","api","module","exports","toRDF","input","options","issuer","IdentifierIssuer","nodeMap","dataset","graphNames","Object","keys","sort","graphName","graphTerm","termType","value","startsWith","eventHandler","event","type","code","level","message","details","graph","_graphToRDF","ids","id","node","properties","property","items","item","subject","predicate","produceGeneralizedRdf","getOldIds","find","key","getId","object","_objectToRDF","rdfDirection","push","_listToRDF","list","first","rest","nil","last","pop","result","next","isValue","undefined","datatype","isBoolean","toString","isDouble","parseFloat","toExponential","replace","isNumber","toFixed","language","isList","_list","isObject"],"sources":["C:/Users/kevin/Desktop/EGS data/Egs-Ladder-Front/EGS-ladder-front/node_modules/jsonld/lib/toRdf.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {createNodeMap} = require('./nodeMap');\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst jsonCanonicalize = require('canonicalize');\nconst types = require('./types');\nconst util = require('./util');\n\nconst {\n  handleEvent: _handleEvent\n} = require('./events');\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {'@default': {}};\n  createNodeMap(input, nodeMap, '@default', issuer);\n\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for(const graphName of graphNames) {\n    let graphTerm;\n    if(graphName === '@default') {\n      graphTerm = {termType: 'DefaultGraph', value: ''};\n    } else if(_isAbsoluteIri(graphName)) {\n      if(graphName.startsWith('_:')) {\n        graphTerm = {termType: 'BlankNode'};\n      } else {\n        graphTerm = {termType: 'NamedNode'};\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'relative graph reference',\n            level: 'warning',\n            message: 'Relative graph reference found.',\n            details: {\n              graph: graphName\n            }\n          },\n          options\n        });\n      }\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for(const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for(let property of properties) {\n      const items = node[property];\n      if(property === '@type') {\n        property = RDF_TYPE;\n      } else if(isKeyword(property)) {\n        continue;\n      }\n\n      for(const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if(!_isAbsoluteIri(id)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative subject reference',\n                level: 'warning',\n                message: 'Relative subject reference found.',\n                details: {\n                  subject: id\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if(!_isAbsoluteIri(property)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative predicate reference',\n                level: 'warning',\n                message: 'Relative predicate reference found.',\n                details: {\n                  predicate: property\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if(predicate.termType === 'BlankNode' &&\n          !options.produceGeneralizedRdf) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'blank node predicate',\n                level: 'warning',\n                message: 'Dropping blank node predicate.',\n                details: {\n                  // FIXME: add better issuer API to get reverse mapping\n                  property: issuer.getOldIds()\n                    .find(key => issuer.getId(key) === property)\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object = _objectToRDF(\n          item, issuer, dataset, graphTerm, options.rdfDirection, options);\n        // skip null objects (they are relative IRIs)\n        if(object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n * @param options the RDF serialization options.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection, options) {\n  const first = {termType: 'NamedNode', value: RDF_FIRST};\n  const rest = {termType: 'NamedNode', value: RDF_REST};\n  const nil = {termType: 'NamedNode', value: RDF_NIL};\n\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {termType: 'BlankNode', value: issuer.getId()} : nil;\n  let subject = result;\n\n  for(const item of list) {\n    const object = _objectToRDF(\n      item, issuer, dataset, graphTerm, rdfDirection, options);\n    const next = {termType: 'BlankNode', value: issuer.getId()};\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if(last) {\n    const object = _objectToRDF(\n      last, issuer, dataset, graphTerm, rdfDirection, options);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n * @param options the RDF serialization options.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(\n  item, issuer, dataset, graphTerm, rdfDirection, options\n) {\n  const object = {};\n\n  // convert value object to RDF\n  if(graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if(datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if(types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if(types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if(!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if(types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if(rdfDirection === 'i18n-datatype' &&\n      '@direction' in item) {\n      const datatype = 'https://www.w3.org/ns/i18n#' +\n        (item['@language'] || '') +\n        `_${item['@direction']}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if(graphTypes.isList(item)) {\n    const _list = _listToRDF(\n      item['@list'], issuer, dataset, graphTerm, rdfDirection, options);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if(object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    if(options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'relative object reference',\n          level: 'warning',\n          message: 'Relative object reference found.',\n          details: {\n            object: object.value\n          }\n        },\n        options\n      });\n    }\n    return null;\n  }\n\n  return object;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}