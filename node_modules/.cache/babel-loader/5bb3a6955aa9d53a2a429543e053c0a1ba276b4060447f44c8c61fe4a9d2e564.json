{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { parse as dereference } from \"jsonref\";\nimport get from \"lodash.get\";\nimport inflection from \"inflection\";\nimport { Field } from \"../Field.js\";\nimport { Operation } from \"../Operation.js\";\nimport { Parameter } from \"../Parameter.js\";\nimport { Resource } from \"../Resource.js\";\nimport getResourcePaths from \"../utils/getResources.js\";\nimport getType from \"./getType.js\";\nconst isRef = maybeRef => !(\"$ref\" in maybeRef);\nexport const removeTrailingSlash = url => {\n  if (url.endsWith(\"/\")) {\n    url = url.slice(0, -1);\n  }\n  return url;\n};\nconst mergeResources = (resourceA, resourceB) => {\n  var _a, _b, _c;\n  (_a = resourceB.fields) === null || _a === void 0 ? void 0 : _a.forEach(fieldB => {\n    var _a, _b;\n    if (!((_a = resourceA.fields) === null || _a === void 0 ? void 0 : _a.some(fieldA => fieldA.name === fieldB.name))) {\n      (_b = resourceA.fields) === null || _b === void 0 ? void 0 : _b.push(fieldB);\n    }\n  });\n  (_b = resourceB.readableFields) === null || _b === void 0 ? void 0 : _b.forEach(fieldB => {\n    var _a, _b;\n    if (!((_a = resourceA.readableFields) === null || _a === void 0 ? void 0 : _a.some(fieldA => fieldA.name === fieldB.name))) {\n      (_b = resourceA.readableFields) === null || _b === void 0 ? void 0 : _b.push(fieldB);\n    }\n  });\n  (_c = resourceB.writableFields) === null || _c === void 0 ? void 0 : _c.forEach(fieldB => {\n    var _a, _b;\n    if (!((_a = resourceA.writableFields) === null || _a === void 0 ? void 0 : _a.some(fieldA => fieldA.name === fieldB.name))) {\n      (_b = resourceA.writableFields) === null || _b === void 0 ? void 0 : _b.push(fieldB);\n    }\n  });\n  return resourceA;\n};\nconst buildResourceFromSchema = (schema, name, title, url) => {\n  const description = schema.description;\n  const properties = schema.properties || {};\n  const fieldNames = Object.keys(properties);\n  const requiredFields = schema.required || [];\n  const readableFields = [];\n  const writableFields = [];\n  const fields = fieldNames.map(fieldName => {\n    const property = properties[fieldName];\n    const type = getType(property.type || \"string\", property.format);\n    const field = new Field(fieldName, {\n      id: null,\n      range: null,\n      type,\n      arrayType: type === \"array\" && \"items\" in property ? getType(property.items.type || \"string\", property.items.format) : null,\n      enum: property.enum ? Object.fromEntries(\n      // Object.values is used because the array is annotated: it contains the __meta symbol used by jsonref.\n      Object.values(property.enum).map(enumValue => [typeof enumValue === \"string\" ? inflection.humanize(enumValue) : enumValue, enumValue])) : null,\n      reference: null,\n      embedded: null,\n      nullable: property.nullable || false,\n      required: !!requiredFields.find(value => value === fieldName),\n      description: property.description || \"\"\n    });\n    if (!property.writeOnly) {\n      readableFields.push(field);\n    }\n    if (!property.readOnly) {\n      writableFields.push(field);\n    }\n    return field;\n  });\n  return new Resource(name, url, {\n    id: null,\n    title,\n    description,\n    fields,\n    readableFields,\n    writableFields,\n    parameters: [],\n    getParameters: () => Promise.resolve([])\n  });\n};\nconst buildOperationFromPathItem = (httpMethod, operationType, pathItem) => {\n  return new Operation(pathItem.summary || operationType, operationType, {\n    method: httpMethod.toUpperCase(),\n    deprecated: !!pathItem.deprecated\n  });\n};\n/*\n  Assumptions:\n  RESTful APIs typically have two paths per resources: a `/noun` path and a\n  `/noun/{id}` path. `getResources` strips out the former, allowing us to focus\n  on the latter.\n\n  In OpenAPI 3, the `/noun/{id}` path will typically have a `get` action, that\n  probably accepts parameters and would respond with an object.\n*/\nexport default function (response, entrypointUrl) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const document = yield dereference(response, {\n      scope: entrypointUrl\n    });\n    const paths = getResourcePaths(document.paths);\n    let serverUrlOrRelative = \"/\";\n    if (document.servers) {\n      serverUrlOrRelative = document.servers[0].url;\n    }\n    const serverUrl = new URL(serverUrlOrRelative, entrypointUrl).href;\n    const resources = [];\n    paths.forEach(path => {\n      const splittedPath = removeTrailingSlash(path).split(\"/\");\n      const name = inflection.pluralize(splittedPath[splittedPath.length - 2]);\n      const url = `${removeTrailingSlash(serverUrl)}/${name}`;\n      const pathItem = document.paths[path];\n      if (!pathItem) {\n        throw new Error();\n      }\n      const title = inflection.classify(splittedPath[splittedPath.length - 2]);\n      const showOperation = pathItem.get;\n      const editOperation = pathItem.put || pathItem.patch;\n      if (!showOperation && !editOperation) return;\n      const showSchema = showOperation ? get(showOperation, \"responses.200.content.application/json.schema\", get(document, `components.schemas[${title}]`)) : null;\n      const editSchema = editOperation ? get(editOperation, \"requestBody.content.application/json.schema\") : null;\n      if (!showSchema && !editSchema) return;\n      const showResource = showSchema ? buildResourceFromSchema(showSchema, name, title, url) : null;\n      const editResource = editSchema ? buildResourceFromSchema(editSchema, name, title, url) : null;\n      let resource = showResource !== null && showResource !== void 0 ? showResource : editResource;\n      if (!resource) return;\n      if (showResource && editResource) {\n        resource = mergeResources(showResource, editResource);\n      }\n      const putOperation = pathItem.put;\n      const patchOperation = pathItem.patch;\n      const deleteOperation = pathItem.delete;\n      const pathCollection = document.paths[`/${name}`];\n      const listOperation = pathCollection && pathCollection.get;\n      const createOperation = pathCollection && pathCollection.post;\n      resource.operations = [...(showOperation ? [buildOperationFromPathItem(\"get\", \"show\", showOperation)] : []), ...(putOperation ? [buildOperationFromPathItem(\"put\", \"edit\", putOperation)] : []), ...(patchOperation ? [buildOperationFromPathItem(\"patch\", \"edit\", patchOperation)] : []), ...(deleteOperation ? [buildOperationFromPathItem(\"delete\", \"delete\", deleteOperation)] : []), ...(listOperation ? [buildOperationFromPathItem(\"get\", \"list\", listOperation)] : []), ...(createOperation ? [buildOperationFromPathItem(\"post\", \"create\", createOperation)] : [])];\n      if (listOperation && listOperation.parameters) {\n        resource.parameters = listOperation.parameters.filter(isRef).map(parameter => new Parameter(parameter.name, parameter.schema && isRef(parameter.schema) ? parameter.schema.type ? getType(parameter.schema.type) : null : null, parameter.required || false, parameter.description || \"\", parameter.deprecated));\n      }\n      resources.push(resource);\n    });\n    // Guess embeddeds and references from property names\n    resources.forEach(resource => {\n      var _a;\n      (_a = resource.fields) === null || _a === void 0 ? void 0 : _a.forEach(field => {\n        const name = inflection.camelize(field.name).replace(/Ids?$/, \"\");\n        const guessedResource = resources.find(res => res.title === inflection.classify(name));\n        if (!guessedResource) {\n          return;\n        }\n        field.maxCardinality = field.type === \"array\" ? null : 1;\n        if (field.type === \"object\" || field.arrayType === \"object\") {\n          field.embedded = guessedResource;\n        } else {\n          field.reference = guessedResource;\n        }\n      });\n    });\n    return resources;\n  });\n}","map":{"version":3,"mappings":"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","names":["parse","dereference","get","inflection","Field","Operation","Parameter","Resource","getResourcePaths","getType","isRef","maybeRef","removeTrailingSlash","url","endsWith","slice","mergeResources","resourceA","resourceB","fields","forEach","fieldB","some","fieldA","name","push","readableFields","writableFields","buildResourceFromSchema","schema","title","description","properties","fieldNames","Object","keys","requiredFields","required","map","fieldName","property","type","format","field","id","range","arrayType","items","enum","fromEntries","values","enumValue","humanize","reference","embedded","nullable","find","value","writeOnly","readOnly","parameters","getParameters","Promise","resolve","buildOperationFromPathItem","httpMethod","operationType","pathItem","summary","method","toUpperCase","deprecated","response","entrypointUrl","document","scope","paths","serverUrlOrRelative","servers","serverUrl","URL","href","resources","path","splittedPath","split","pluralize","length","Error","classify","showOperation","editOperation","put","patch","showSchema","editSchema","showResource","editResource","resource","putOperation","patchOperation","deleteOperation","delete","pathCollection","listOperation","createOperation","post","operations","filter","parameter","camelize","replace","guessedResource","res","maxCardinality"],"sources":["C:\\Users\\kevin\\Desktop\\EGS data\\Egs-Ladder-Front\\EGS-ladder-front\\node_modules\\@api-platform\\api-doc-parser\\src\\openapi3\\handleJson.ts"],"sourcesContent":["import { parse as dereference } from \"jsonref\";\nimport get from \"lodash.get\";\nimport inflection from \"inflection\";\nimport { Field } from \"../Field.js\";\nimport { Operation } from \"../Operation.js\";\nimport { Parameter } from \"../Parameter.js\";\nimport { Resource } from \"../Resource.js\";\nimport getResourcePaths from \"../utils/getResources.js\";\nimport getType from \"./getType.js\";\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport type { OperationType } from \"../Operation.js\";\n\nconst isRef = <T>(maybeRef: T | OpenAPIV3.ReferenceObject): maybeRef is T =>\n  !(\"$ref\" in maybeRef);\n\nexport const removeTrailingSlash = (url: string): string => {\n  if (url.endsWith(\"/\")) {\n    url = url.slice(0, -1);\n  }\n  return url;\n};\n\nconst mergeResources = (resourceA: Resource, resourceB: Resource) => {\n  resourceB.fields?.forEach((fieldB) => {\n    if (!resourceA.fields?.some((fieldA) => fieldA.name === fieldB.name)) {\n      resourceA.fields?.push(fieldB);\n    }\n  });\n  resourceB.readableFields?.forEach((fieldB) => {\n    if (\n      !resourceA.readableFields?.some((fieldA) => fieldA.name === fieldB.name)\n    ) {\n      resourceA.readableFields?.push(fieldB);\n    }\n  });\n  resourceB.writableFields?.forEach((fieldB) => {\n    if (\n      !resourceA.writableFields?.some((fieldA) => fieldA.name === fieldB.name)\n    ) {\n      resourceA.writableFields?.push(fieldB);\n    }\n  });\n\n  return resourceA;\n};\n\nconst buildResourceFromSchema = (\n  schema: OpenAPIV3.SchemaObject,\n  name: string,\n  title: string,\n  url: string\n) => {\n  const description = schema.description;\n  const properties = schema.properties || {};\n\n  const fieldNames = Object.keys(properties);\n  const requiredFields = schema.required || [];\n\n  const readableFields: Field[] = [];\n  const writableFields: Field[] = [];\n\n  const fields = fieldNames.map((fieldName) => {\n    const property = properties[fieldName] as OpenAPIV3.SchemaObject;\n\n    const type = getType(property.type || \"string\", property.format);\n    const field = new Field(fieldName, {\n      id: null,\n      range: null,\n      type,\n      arrayType:\n        type === \"array\" && \"items\" in property\n          ? getType(\n              (property.items as OpenAPIV3.SchemaObject).type || \"string\",\n              (property.items as OpenAPIV3.SchemaObject).format\n            )\n          : null,\n      enum: property.enum\n        ? Object.fromEntries(\n            // Object.values is used because the array is annotated: it contains the __meta symbol used by jsonref.\n            Object.values<string | number>(property.enum).map((enumValue) => [\n              typeof enumValue === \"string\"\n                ? inflection.humanize(enumValue)\n                : enumValue,\n              enumValue,\n            ])\n          )\n        : null,\n      reference: null,\n      embedded: null,\n      nullable: property.nullable || false,\n      required: !!requiredFields.find((value) => value === fieldName),\n      description: property.description || \"\",\n    });\n\n    if (!property.writeOnly) {\n      readableFields.push(field);\n    }\n    if (!property.readOnly) {\n      writableFields.push(field);\n    }\n\n    return field;\n  });\n\n  return new Resource(name, url, {\n    id: null,\n    title,\n    description,\n    fields,\n    readableFields,\n    writableFields,\n    parameters: [],\n    getParameters: () => Promise.resolve([]),\n  });\n};\n\nconst buildOperationFromPathItem = (\n  httpMethod: `${OpenAPIV3.HttpMethods}`,\n  operationType: OperationType,\n  pathItem: OpenAPIV3.OperationObject\n): Operation => {\n  return new Operation(pathItem.summary || operationType, operationType, {\n    method: httpMethod.toUpperCase(),\n    deprecated: !!pathItem.deprecated,\n  });\n};\n\n/*\n  Assumptions:\n  RESTful APIs typically have two paths per resources: a `/noun` path and a\n  `/noun/{id}` path. `getResources` strips out the former, allowing us to focus\n  on the latter.\n\n  In OpenAPI 3, the `/noun/{id}` path will typically have a `get` action, that\n  probably accepts parameters and would respond with an object.\n*/\n\nexport default async function (\n  response: OpenAPIV3.Document,\n  entrypointUrl: string\n): Promise<Resource[]> {\n  const document = (await dereference(response, {\n    scope: entrypointUrl,\n  })) as OpenAPIV3.Document;\n\n  const paths = getResourcePaths(document.paths);\n\n  let serverUrlOrRelative = \"/\";\n  if (document.servers) {\n    serverUrlOrRelative = document.servers[0].url;\n  }\n\n  const serverUrl = new URL(serverUrlOrRelative, entrypointUrl).href;\n\n  const resources: Resource[] = [];\n\n  paths.forEach((path) => {\n    const splittedPath = removeTrailingSlash(path).split(\"/\");\n    const name = inflection.pluralize(splittedPath[splittedPath.length - 2]);\n    const url = `${removeTrailingSlash(serverUrl)}/${name}`;\n    const pathItem = document.paths[path];\n    if (!pathItem) {\n      throw new Error();\n    }\n\n    const title = inflection.classify(splittedPath[splittedPath.length - 2]);\n\n    const showOperation = pathItem.get;\n    const editOperation = pathItem.put || pathItem.patch;\n    if (!showOperation && !editOperation) return;\n\n    const showSchema = showOperation\n      ? (get(\n          showOperation,\n          \"responses.200.content.application/json.schema\",\n          get(document, `components.schemas[${title}]`)\n        ) as OpenAPIV3.SchemaObject)\n      : null;\n    const editSchema = editOperation\n      ? (get(\n          editOperation,\n          \"requestBody.content.application/json.schema\"\n        ) as OpenAPIV3.SchemaObject)\n      : null;\n\n    if (!showSchema && !editSchema) return;\n\n    const showResource = showSchema\n      ? buildResourceFromSchema(showSchema, name, title, url)\n      : null;\n    const editResource = editSchema\n      ? buildResourceFromSchema(editSchema, name, title, url)\n      : null;\n    let resource = showResource ?? editResource;\n    if (!resource) return;\n    if (showResource && editResource) {\n      resource = mergeResources(showResource, editResource);\n    }\n\n    const putOperation = pathItem.put;\n    const patchOperation = pathItem.patch;\n    const deleteOperation = pathItem.delete;\n    const pathCollection = document.paths[`/${name}`];\n    const listOperation = pathCollection && pathCollection.get;\n    const createOperation = pathCollection && pathCollection.post;\n    resource.operations = [\n      ...(showOperation\n        ? [buildOperationFromPathItem(\"get\", \"show\", showOperation)]\n        : []),\n      ...(putOperation\n        ? [buildOperationFromPathItem(\"put\", \"edit\", putOperation)]\n        : []),\n      ...(patchOperation\n        ? [buildOperationFromPathItem(\"patch\", \"edit\", patchOperation)]\n        : []),\n      ...(deleteOperation\n        ? [buildOperationFromPathItem(\"delete\", \"delete\", deleteOperation)]\n        : []),\n      ...(listOperation\n        ? [buildOperationFromPathItem(\"get\", \"list\", listOperation)]\n        : []),\n      ...(createOperation\n        ? [buildOperationFromPathItem(\"post\", \"create\", createOperation)]\n        : []),\n    ];\n\n    if (listOperation && listOperation.parameters) {\n      resource.parameters = listOperation.parameters\n        .filter(isRef)\n        .map(\n          (parameter) =>\n            new Parameter(\n              parameter.name,\n              parameter.schema && isRef(parameter.schema)\n                ? parameter.schema.type\n                  ? getType(parameter.schema.type)\n                  : null\n                : null,\n              parameter.required || false,\n              parameter.description || \"\",\n              parameter.deprecated\n            )\n        );\n    }\n\n    resources.push(resource);\n  });\n\n  // Guess embeddeds and references from property names\n  resources.forEach((resource) => {\n    resource.fields?.forEach((field) => {\n      const name = inflection.camelize(field.name).replace(/Ids?$/, \"\");\n\n      const guessedResource = resources.find(\n        (res) => res.title === inflection.classify(name)\n      );\n      if (!guessedResource) {\n        return;\n      }\n      field.maxCardinality = field.type === \"array\" ? null : 1;\n      if (field.type === \"object\" || field.arrayType === \"object\") {\n        field.embedded = guessedResource;\n      } else {\n        field.reference = guessedResource;\n      }\n    });\n  });\n\n  return resources;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}