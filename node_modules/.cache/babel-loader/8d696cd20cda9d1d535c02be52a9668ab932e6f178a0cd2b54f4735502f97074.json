{"ast":null,"code":"import { __awaiter } from \"tslib\";\nconst setOptions = (query, options) => {\n  if (!options.method) {\n    options.method = \"POST\";\n  }\n  if (!(options.headers instanceof Headers)) {\n    options.headers = new Headers(options.headers);\n  }\n  if (null === options.headers.get(\"Content-Type\")) {\n    options.headers.set(\"Content-Type\", \"application/json\");\n  }\n  if (\"GET\" !== options.method && !options.body) {\n    options.body = JSON.stringify({\n      query\n    });\n  }\n  return options;\n};\nexport default (function (url, query) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const response = yield fetch(url, setOptions(query, options));\n    const body = yield response.json();\n    if (body === null || body === void 0 ? void 0 : body.errors) {\n      return Promise.reject({\n        response,\n        body\n      });\n    }\n    return Promise.resolve({\n      response,\n      body\n    });\n  });\n});","map":{"version":3,"mappings":";AAEA,MAAMA,UAAU,GAAG,CAACC,KAAa,EAAEC,OAAoB,KAAiB;EACtE,IAAI,CAACA,OAAO,CAACC,MAAM,EAAE;IACnBD,OAAO,CAACC,MAAM,GAAG,MAAM;;EAGzB,IAAI,EAAED,OAAO,CAACE,OAAO,YAAYC,OAAO,CAAC,EAAE;IACzCH,OAAO,CAACE,OAAO,GAAG,IAAIC,OAAO,CAACH,OAAO,CAACE,OAAO,CAAC;;EAGhD,IAAI,IAAI,KAAKF,OAAO,CAACE,OAAO,CAACE,GAAG,CAAC,cAAc,CAAC,EAAE;IAChDJ,OAAO,CAACE,OAAO,CAACG,GAAG,CAAC,cAAc,EAAE,kBAAkB,CAAC;;EAGzD,IAAI,KAAK,KAAKL,OAAO,CAACC,MAAM,IAAI,CAACD,OAAO,CAACM,IAAI,EAAE;IAC7CN,OAAO,CAACM,IAAI,GAAGC,IAAI,CAACC,SAAS,CAAC;MAAET;IAAK,CAAE,CAAC;;EAG1C,OAAOC,OAAO;AAChB,CAAC;AAED,gBAAe,UACbS,GAAW,EACXV,KAAa;EAAA,IACbC,8EAAuB,EAAE;EAAA,OAItBU;IACH,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACH,GAAG,EAAEX,UAAU,CAACC,KAAK,EAAEC,OAAO,CAAC,CAAC;IAC7D,MAAMM,IAAI,GAAI,MAAMK,QAAQ,CAACE,IAAI,EAA6B;IAE9D,IAAIP,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEQ,MAAM,EAAE;MAChB,OAAOC,OAAO,CAACC,MAAM,CAAC;QAAEL,QAAQ;QAAEL;MAAI,CAAE,CAAC;;IAG3C,OAAOS,OAAO,CAACE,OAAO,CAAC;MAAEN,QAAQ;MAAEL;IAAI,CAAE,CAAC;EAC5C,CAAC;AAAA","names":["setOptions","query","options","method","headers","Headers","get","set","body","JSON","stringify","url","__awaiter","response","fetch","json","errors","Promise","reject","resolve"],"sources":["C:\\Users\\kevin\\Desktop\\EGS data\\Egs-Ladder-Front\\EGS-ladder-front\\node_modules\\@api-platform\\api-doc-parser\\src\\graphql\\fetchQuery.ts"],"sourcesContent":["import type { ExecutionResult } from \"graphql\";\n\nconst setOptions = (query: string, options: RequestInit): RequestInit => {\n  if (!options.method) {\n    options.method = \"POST\";\n  }\n\n  if (!(options.headers instanceof Headers)) {\n    options.headers = new Headers(options.headers);\n  }\n\n  if (null === options.headers.get(\"Content-Type\")) {\n    options.headers.set(\"Content-Type\", \"application/json\");\n  }\n\n  if (\"GET\" !== options.method && !options.body) {\n    options.body = JSON.stringify({ query });\n  }\n\n  return options;\n};\n\nexport default async <TData = { [key: string]: unknown }>(\n  url: string,\n  query: string,\n  options: RequestInit = {}\n): Promise<{\n  response: Response;\n  body: ExecutionResult<TData>;\n}> => {\n  const response = await fetch(url, setOptions(query, options));\n  const body = (await response.json()) as ExecutionResult<TData>;\n\n  if (body?.errors) {\n    return Promise.reject({ response, body });\n  }\n\n  return Promise.resolve({ response, body });\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}