{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst {\n  REGEX_BCP47,\n  addValue: _addValue\n} = require('./util');\nconst {\n  handleEvent: _handleEvent\n} = require('./events');\n\n// constants\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING\n} = require('./constants');\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = async (dataset, options) => {\n  const defaultGraph = {};\n  const graphMap = {\n    '@default': defaultGraph\n  };\n  const referencedOnce = {};\n  const {\n    useRdfType = false,\n    useNativeTypes = false,\n    rdfDirection = null\n  } = options;\n  for (const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = quad.graph.termType === 'DefaultGraph' ? '@default' : quad.graph.value;\n    if (!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if (name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {\n        '@id': name\n      };\n    }\n    const nodeMap = graphMap[name];\n\n    // get subject, predicate, object\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n    if (!(s in nodeMap)) {\n      nodeMap[s] = {\n        '@id': s\n      };\n    }\n    const node = nodeMap[s];\n    const objectIsNode = o.termType.endsWith('Node');\n    if (objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {\n        '@id': o.value\n      };\n    }\n    if (p === RDF_TYPE && !useRdfType && objectIsNode) {\n      _addValue(node, '@type', o.value, {\n        propertyIsArray: true\n      });\n      continue;\n    }\n    const value = _RDFToObject(o, useNativeTypes, rdfDirection, options);\n    _addValue(node, p, value, {\n      propertyIsArray: true\n    });\n\n    // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n    if (objectIsNode) {\n      if (o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n        if (!('usages' in object)) {\n          object.usages = [];\n        }\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if (o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n       // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n       if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n       const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n       if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        _addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n       const value = _RDFToObject(o, useNativeTypes);\n      _addValue(node, p, value, {propertyIsArray: true});\n       // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n\n  // convert linked lists to @list arrays\n  for (const name in graphMap) {\n    const graphObject = graphMap[name];\n\n    // no @lists to be converted, continue\n    if (!(RDF_NIL in graphObject)) {\n      continue;\n    }\n\n    // iterate backwards through each RDF list\n    const nil = graphObject[RDF_NIL];\n    if (!nil.usages) {\n      continue;\n    }\n    for (let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = [];\n\n      // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n      let nodeKeyCount = Object.keys(node).length;\n      while (property === RDF_REST && types.isObject(referencedOnce[node['@id']]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node['@type']) && node['@type'].length === 1 && node['@type'][0] === RDF_LIST)) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']);\n\n        // get next node, moving backwards through list\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length;\n\n        // if node is not a blank node, then list head found\n        if (!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      }\n\n      // transform list into @list object\n      delete head['@id'];\n      head['@list'] = list.reverse();\n      for (const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n    delete nil.usages;\n  }\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n  for (const subject of subjects) {\n    const node = defaultGraph[subject];\n    if (subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n      for (const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject];\n        // only add full subjects to top-level\n        if (!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    }\n    // only add full subjects to top-level\n    if (!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n  return result;\n};\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n * @param rdfDirection text direction mode [null, i18n-datatype]\n * @param options top level API options\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes, rdfDirection, options) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if (o.termType.endsWith('Node')) {\n    return {\n      '@id': o.value\n    };\n  }\n\n  // convert literal to JSON-LD\n  const rval = {\n    '@value': o.value\n  };\n\n  // add language\n  if (o.language) {\n    if (!o.language.match(REGEX_BCP47)) {\n      if (options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'invalid @language value',\n            level: 'warning',\n            message: '@language value must be valid BCP47.',\n            details: {\n              language: o.language\n            }\n          },\n          options\n        });\n      }\n    }\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n    if (!type) {\n      type = XSD_STRING;\n    }\n    if (type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch (e) {\n        throw new JsonLdError('JSON literal could not be parsed.', 'jsonld.InvalidJsonLiteral', {\n          code: 'invalid JSON literal',\n          value: rval['@value'],\n          cause: e\n        });\n      }\n    }\n    // use native types for certain xsd types\n    if (useNativeTypes) {\n      if (type === XSD_BOOLEAN) {\n        if (rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if (rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if (types.isNumeric(rval['@value'])) {\n        if (type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n          if (i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if (type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if (rdfDirection === 'i18n-datatype' && type.startsWith('https://www.w3.org/ns/i18n#')) {\n      const [, language, direction] = type.split(/[#_]/);\n      if (language.length > 0) {\n        rval['@language'] = language;\n        if (!language.match(REGEX_BCP47)) {\n          if (options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language\n                }\n              },\n              options\n            });\n          }\n        }\n      }\n      rval['@direction'] = direction;\n    } else if (type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n  return rval;\n}","map":{"version":3,"names":["JsonLdError","require","graphTypes","types","REGEX_BCP47","addValue","_addValue","handleEvent","_handleEvent","RDF_LIST","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","api","module","exports","fromRDF","dataset","options","defaultGraph","graphMap","referencedOnce","useRdfType","useNativeTypes","rdfDirection","quad","name","graph","termType","value","nodeMap","s","subject","p","predicate","o","object","node","objectIsNode","endsWith","propertyIsArray","_RDFToObject","usages","push","property","graphObject","nil","usage","head","list","listNodes","nodeKeyCount","Object","keys","length","isObject","isArray","isBlankNode","reverse","listNode","result","subjects","sort","graphSubjects","graphSubject","isSubjectReference","rval","language","match","eventHandler","event","type","code","level","message","details","datatype","JSON","parse","e","cause","isNumeric","i","parseInt","toFixed","parseFloat","includes","startsWith","direction","split"],"sources":["C:/Users/kevin/Desktop/EGS data/Egs-Ladder-Front/EGS-ladder-front/node_modules/jsonld/lib/fromRdf.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\n\nconst {\n  REGEX_BCP47,\n  addValue: _addValue\n} = require('./util');\n\nconst {\n  handleEvent: _handleEvent\n} = require('./events');\n\n// constants\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = async (\n  dataset,\n  options\n) => {\n  const defaultGraph = {};\n  const graphMap = {'@default': defaultGraph};\n  const referencedOnce = {};\n  const {\n    useRdfType = false,\n    useNativeTypes = false,\n    rdfDirection = null\n  } = options;\n\n  for(const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = (quad.graph.termType === 'DefaultGraph') ?\n      '@default' : quad.graph.value;\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n\n    const nodeMap = graphMap[name];\n\n    // get subject, predicate, object\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n\n    if(!(s in nodeMap)) {\n      nodeMap[s] = {'@id': s};\n    }\n    const node = nodeMap[s];\n\n    const objectIsNode = o.termType.endsWith('Node');\n    if(objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {'@id': o.value};\n    }\n\n    if(p === RDF_TYPE && !useRdfType && objectIsNode) {\n      _addValue(node, '@type', o.value, {propertyIsArray: true});\n      continue;\n    }\n\n    const value = _RDFToObject(o, useNativeTypes, rdfDirection, options);\n    _addValue(node, p, value, {propertyIsArray: true});\n\n    // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n    if(objectIsNode) {\n      if(o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n        if(!('usages' in object)) {\n          object.usages = [];\n        }\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if(o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n\n      // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n\n      if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n\n      const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n\n      if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        _addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n\n      const value = _RDFToObject(o, useNativeTypes);\n      _addValue(node, p, value, {propertyIsArray: true});\n\n      // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n\n  // convert linked lists to @list arrays\n  for(const name in graphMap) {\n    const graphObject = graphMap[name];\n\n    // no @lists to be converted, continue\n    if(!(RDF_NIL in graphObject)) {\n      continue;\n    }\n\n    // iterate backwards through each RDF list\n    const nil = graphObject[RDF_NIL];\n    if(!nil.usages) {\n      continue;\n    }\n    for(let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = [];\n\n      // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n      let nodeKeyCount = Object.keys(node).length;\n      while(property === RDF_REST &&\n        types.isObject(referencedOnce[node['@id']]) &&\n        types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 &&\n        types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 &&\n        (nodeKeyCount === 3 ||\n          (nodeKeyCount === 4 && types.isArray(node['@type']) &&\n          node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']);\n\n        // get next node, moving backwards through list\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length;\n\n        // if node is not a blank node, then list head found\n        if(!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      }\n\n      // transform list into @list object\n      delete head['@id'];\n      head['@list'] = list.reverse();\n      for(const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n\n    delete nil.usages;\n  }\n\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n  for(const subject of subjects) {\n    const node = defaultGraph[subject];\n    if(subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n      for(const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject];\n        // only add full subjects to top-level\n        if(!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    }\n    // only add full subjects to top-level\n    if(!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n * @param rdfDirection text direction mode [null, i18n-datatype]\n * @param options top level API options\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes, rdfDirection, options) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if(o.termType.endsWith('Node')) {\n    return {'@id': o.value};\n  }\n\n  // convert literal to JSON-LD\n  const rval = {'@value': o.value};\n\n  // add language\n  if(o.language) {\n    if(!o.language.match(REGEX_BCP47)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'invalid @language value',\n            level: 'warning',\n            message: '@language value must be valid BCP47.',\n            details: {\n              language: o.language\n            }\n          },\n          options\n        });\n      }\n    }\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n    if(!type) {\n      type = XSD_STRING;\n    }\n    if(type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch(e) {\n        throw new JsonLdError(\n          'JSON literal could not be parsed.',\n          'jsonld.InvalidJsonLiteral',\n          {code: 'invalid JSON literal', value: rval['@value'], cause: e});\n      }\n    }\n    // use native types for certain xsd types\n    if(useNativeTypes) {\n      if(type === XSD_BOOLEAN) {\n        if(rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if(rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if(types.isNumeric(rval['@value'])) {\n        if(type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n          if(i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if(type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if(![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if(rdfDirection === 'i18n-datatype' &&\n      type.startsWith('https://www.w3.org/ns/i18n#')) {\n      const [, language, direction] = type.split(/[#_]/);\n      if(language.length > 0) {\n        rval['@language'] = language;\n        if(!language.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language\n                }\n              },\n              options\n            });\n          }\n        }\n      }\n      rval['@direction'] = direction;\n    } else if(type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}